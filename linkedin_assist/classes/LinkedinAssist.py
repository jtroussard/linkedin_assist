from quick_fixes.oauth2_session import OAuth2Session
from requests_oauthlib.compliance_fixes import linkedin_compliance_fix

from dnt import vault
from time import sleep

import os, json

class LinkedinAssist():
    """Creates a very manual type connection to LinkedIn API,
    and then acts as a delivery vehicle for formated posts.
    """

    def __init__(self, config, job_data=[], session=None):
        """Construct a new LinkedinAssist Object.

        :param job_data: list of JSON objects containing job post 
                         data. Data is unformated for Linkedin
                         share ppost.
        :param session: Linkedin OAuth2 session obj."""
        self.job_data = job_data
        self.session = session
        self.config = config

    def make_connection(self):
        """Have the user authenticate."""

        """ This is NOT a production quality program ad the os environ attr
        is being set accordingly. Only run this program locally"""
        os.environ['OAUTHLIB_INSECURE_TRANSPORT'] = '1'

        """ Made some changes to OAuth2Session class to work around some 
        bugs introduced by linkedin's API updates and changes."""
        #from requests_oauthlib import OAuth2Session
        from quick_fixes.oauth2_session import OAuth2Session
        from requests_oauthlib.compliance_fixes import linkedin_compliance_fix

        # Credentials you get from registering a new application
        client_id = vault.CLIENT_ID
        client_secret = vault.CLIENT_SECRET

        # Scope is necessary to avoid permission errors
        scope = ['r_liteprofile', 'w_member_social']
        redirect_url = self.config['URLS']['li_api_redirect']

        # OAuth endpoints given in the LinkedIn API documentation .
        authorization_base_url = self.config['URLS']['li_api_auth_base']
        token_url = self.config['URLS']['li_api_token']

        # Authorized Redirect URL (from LinkedIn configuration)
        self.session = OAuth2Session(client_id, redirect_uri=redirect_url, scope=scope)
        self.session = linkedin_compliance_fix(self.session)
        authorization_url, state = self.session.authorization_url(authorization_base_url)

        # Alert user of browser action and to return to terminal
        input("Attention! A browser will open after you confirm this step.\nPlease athenticate, copy the redirect url, and paste it into the next terminal prompt. Press any key to continue.")

        # Redirect user to LinkedIn for authorization
        import webbrowser
        webbrowser.open(authorization_url)
        
        # Get the authorization verifier code from the callback url
        redirect_response = input('Paste the full redirect URL here:')
        self.session.fetch_token(token_url,client_secret=client_secret,include_client_id=True,authorization_response=redirect_response)
        return self.session.authorized

    def get_urn(self, res_link):
        # Extract the Linkedin URN
        r = self.session.get(res_link)
        return r.json()['id']

    def form_posts(self, job_list, urn):
        req_data = []

        for job in job_list:
            p = {
            "author": "urn:li:person:{}".format(str(urn)),
            "lifecycleState": "PUBLISHED",
            "specificContent": {
                "com.linkedin.ugc.ShareContent": {
                    "shareCommentary": {
                        "text": "{} area IT job seekers, Dollar Bank is looking for a wicked talented {} to join our team! Interested? Follow this link to apply, referral mentions greatly appreciated! Also, did you know? This post was generated by a python script, check my github(jtroussard) account for more details.".format(job['location'], job['title']),
                    },
                    "shareMediaCategory": "ARTICLE",
                    "media": [
                        {
                            "status": "READY",
                            "description": {
                                "text": "{} - {}".format(job['title'], job['location'])
                            },
                            "originalUrl": job['url'],
                        }
                    ]
                }
            },
            "visibility": {
                "com.linkedin.ugc.MemberNetworkVisibility": "CONNECTIONS"
                }
            }
            req_data.append(json.dumps(p))
        return req_data                

    # The returns for this function definitely feel stupid. Sleep on this and figure out a less convoluted way of returning status on this function.
    def make_posts(self, req_data):
        status = 0
        req_link = self.config['URLS']['li_api_share']
        for formatted_share_request in req_data:
            if self.config['RUN_TYPE'] == 'PRODUCTION':
                r = self.session.post(req_link, data=formatted_share_request, headers={'Content-Type':'application/json','X-Restli-Protocol-Version':'2.0.0','x-li-format':'json'})
                print(r.status_code)
                print(r.text)
                sleep(10)
            elif self.config['RUN_TYPE'] == 'DEVELOPMENT':
                print("---------------test post print--------------------")
                import pprint
                pp = pprint.PrettyPrinter(indent=4)
                pp.pprint(formatted_share_request)
                print("\n\n")
        return True